{"title":"A multi-dimensional view of Firefox users","cells":[{"content":"The plot below attempts to give an overview of Firefox users across a number of attributes recorded for each Firefox profile. At top is a correlation matrix, which gives an overview of the relationships between the variables. Below that are two scatter plots; the first shows the _measured values_ (excluding the top and bottom .5%), and the second shows the _percentile rank_ of each measurement ordered from lowest observed to highest observed.\n\nHovering over a cell in the matrix will show the numerical value of the Spearman rank corellation for the variables in question; clicking that cell will update the scatter plots.","id":1,"cellType":"markdown","value":"<p>The plot below attempts to give an overview of Firefox users across a number of attributes recorded for each Firefox profile. At top is a correlation matrix, which gives an overview of the relationships between the variables. Below that are two scatter plots; the first shows the <em>measured values</em> (excluding the top and bottom .5%), and the second shows the <em>percentile rank</em> of each measurement ordered from lowest observed to highest observed.</p>\n<p>Hovering over a cell in the matrix will show the numerical value of the Spearman rank corellation for the variables in question; clicking that cell will update the scatter plots.</p>\n","rendered":true,"selected":false,"executionStatus":" ","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"EXPANDED","collapsePresentationViewOutput":"EXPANDED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"https://cdnjs.cloudflare.com/ajax/libs/d3/4.10.2/d3.js\nhttps://cdn.jsdelivr.net/npm/lodash@4.17.4/lodash.min.js\nhttps://cdnjs.cloudflare.com/ajax/libs/jstat/1.7.0/jstat.min.js\ntools/nb-tools.js","id":0,"cellType":"external scripts","value":"loaded scripts","rendered":true,"selected":false,"executionStatus":"10","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"COLLAPSED","presentation":"COLLAPSED"}}},{"content":"let URL = 'https://gist.githubusercontent.com/bcolloran/e7291724246f800e66fd5212d36f30e0/raw/eef91a9f92d9c508171ee8323c734d1c52ec8b36/longitudinal28Day_sampleDf_fbertsch_2017-04-24.csv'\nvar rawData = d3.csvParse(NB.getData(URL))","id":4,"cellType":"javascript","rendered":true,"selected":true,"executionStatus":"11","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"var columns = Object.keys(rawData[0])","id":6,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"12","evaluationOld":true,"collapseEditViewInput":"SCROLLABLE","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"var nb = {}\n\nnb.all = function(arr){\n  for (var i=0; i<arr.length; i++) {\n    if (!arr[i]){return false};\n  }\n  return true\n}\nnb.any = function(arr){\n  for (var i=0; i<arr.length; i++) {\n    if (arr[i]){return true};\n  }\n  return false\n}\n\n// nb.isValuesArray = function(obj){\n//   if (nb.isArray(obj)){\n//     return nb.all(obj.map(x => typ))\n//   } else {return false}\n// }\n\nnb.isMatrixLike = function(obj){\n  if (nb.isArray(obj)){\n    return nb.all(obj.map(nb.isArray))\n  } else {return false}\n}\n\nnb.arrayEqual = function(a1,a2){\n  if (a1.length != a2.length){return false}\n  for (let i=0, l=a1.length; i<l; i++){\n    if (a1[i]!=a2[i]){return false}\n  }\n  return true;\n}\n\nnb.sameKeys = function(x,y){\n  return nb.arrayEqual(_.sortBy(_.keys(x)), _.sortBy(_.keys(y)))\n}\n\nnb.isRowDf = function(obj,rowsToCheck = 100){\n  if (!_.isArray(obj) || obj.length==0) {return false}\n  var rowsToCheck = Math.min(rowsToCheck,_.size(obj))\n  for (let i=1; i<rowsToCheck; i++){\n    if (! _.isPlainObject(obj[i])) {return false}\n    if (!nb.sameKeys(obj[0],obj[i])) {return false}\n  }\n  return true\n}\n\nnb.isMatrix = function(obj,rowsToCheck = 100){\n  if (!_.isArray(obj) || obj.length==0) {return false}\n  var rowsToCheck = Math.min(rowsToCheck,_.size(obj))\n  for (let i=0; i<rowsToCheck; i++){\n    if (! _.isArray(obj[i]) || obj.length==0) {return false}\n    if (! obj[0].length===obj[i].length) {return false}\n  }\n  return true\n}\n\n\nnb.isColumnDf = function(obj,colsToCheck = 100){\n  if (!_.isPlainObject(obj)) {return false}\n  var colsToCheck = Math.min(colsToCheck,_.size(obj))\n  var cols = Object.keys(obj)\n  var numRows = obj[cols[0]].length\n  for (let i=1; i<colsToCheck; i++){\n    if (obj[cols[i]].length != numRows)\n    return false\n  }\n  return true\n}\n\n\nnb.nanComparison = function(a,b){\n  if (!isNaN(a-b)) {return a<b ? -1 : 1} //use numeric sort\n  else {return isNaN(a) ? 1:-1}  // if a is nan, sort it *after* b\n}\n  \nnb.rank = function(arr) {\n  let rank = 1\n  let rankMapping = {}\n  arr.slice()\n    .sort(nb.nanComparison) // sort arr pairs (pushing NaNs to end)\n    .forEach( (x,i) => { //build up the rankMapping\n    if (i===0){ rankMapping[x]=rank }\n    if (i>0){\n      if (x>arr[i-1]){rank++}\n      rankMapping[x]=rank\n    }  \n  })\n  return arr.map(item => isNaN(item) ? NaN : rankMapping[item] )\n}\n\nnb.toColumns = function(rowDF){\n  let cols = _.keys(rowDF[0])\n  let columnar = {}\n  for (col of cols){\n    let colData = rowDF.map(row => row[col])\n    columnar[col] = colData\n  }\n  return columnar\n}\n\nnb.toRows = function(colDf){\n  let cols = Object.keys(colDf)\n  let outDf = [];\n  for (let i=0; i<colDf[cols[0]].length; i++){\n    outDf.push(_.fromPairs(cols.map(col => [col,colDf[col][i]])))\n  }\n  return outDf\n}\n\nnb.shape = function(obj){\n  // rows by cols\n  if (nb.isColumnDf(obj)){\n    console.log\n    let cols = _.keys(obj)\n    return [obj[cols[0]].length, cols.length]\n  } else if (nb.isRowDf(obj)){\n    return ([_.size(obj), _.size(obj[0])])\n  } else if (nb.isMatrix(obj)){\n    return [obj.length, obj[0].length]\n  } else {\n    return [undefined,undefined]\n  } \n}\n\nnb.dropRowsWithNaN = function(col1,col2){\n  return _.unzip( _.zip(col1,col2).filter(xy => !(_.isNaN(xy[0]) || _.isNaN(xy[1]))) )\n}\n\nnb.prettyFormatNumber = function(x,numChars=8){\n  numChars = numChars<=4 ? 4 : numChars\n  if(!_.isNumber(x)){return x}\n  var str = x.toString()\n  if (str.length<=numChars) {return str}\n  var [intStr,decStr] = str.split(\".\")\n  if (intStr.length >= numChars){\n    return x.toExponential(numChars-4)\n  } else if (intStr==\"0\" && decStr.length >= numChars-2){\n\treturn x.toFixed(numChars-2)\n  } else if (intStr==\"-0\" && decStr.length >= numChars-3){\n\treturn x.toFixed(numChars-2)\n    \n  } else {\n    return x.toFixed(numChars-intStr.length-2)\n  }\n}\n\nnb.cartesianProduct = function(a1,a2){\n  var out = []\n  for (x of a1){\n    for (y of a2){\n      out.push([x,y])\n    }\n  }\n  return out\n}\n","id":22,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"13","evaluationOld":true,"collapseEditViewInput":"SCROLLABLE","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"// parse the numerics columns\nvar numericCols = columns.filter(col => {\n  colData = rawData.map(row => row[col])\n  return _.find(colData.map(parseFloat))\n})\nvar df = _(rawData)\n    .map(r => _.pick(r,numericCols))\n    .map(r => _.mapValues(r,parseFloat))\n\t.value()","id":11,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"14","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"var dfCols = nb.toColumns(df)\nvar rankColDf = _.mapValues(dfCols, nb.rank)\nvar rankRowDf = nb.toRows(rankColDf)","id":42,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"15","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"var centralProp = .01\nvar centralExtents = _.fromPairs(\n  numericCols.map(function(c){\n    let col = dfCols[c].filter(x=>!_.isNaN(x)).sort(nb.nanComparison)\n    return [c, [d3.quantile(col, centralProp/2), d3.quantile(col, 1-centralProp/2)] ]\n  })\n)","id":45,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"16","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"var rankCorrMat = jStat.zeros(nb.shape(df)[1])\n// populate the correlation matrix\n_.range(0,nb.shape(df)[1]).forEach(\n  i => _.range(i,nb.shape(df)[1]).forEach(function(j){\n    if (i==j) { \n      rankCorrMat[i][j]=1     \n    } else{\n    var cols = nb.dropRowsWithNaN( rankColDf[numericCols[i]], rankColDf[numericCols[j]] )\n    rankCorrMat[i][j] = jStat.corrcoeff( cols[0],cols[1] );\n    rankCorrMat[j][i] = rankCorrMat[i][j]\n    }\n  })\n)\n\n// rankCorrMat\nvar indices = nb.cartesianProduct(_.range(numericCols.length),\n                              _.range(numericCols.length))","id":18,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"17","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"let xColInit=\"uri_count_total\"\nlet yColInit=\"active_ticks_total\"\nlet scatterAlpha = 0.2;\nlet scatterPointSize = .5;\n\n// standard d3 plot setup\nlet margin = {top:200, right: 80, bottom: 25, left: 230}\n  width = 800 - margin.left - margin.right,\n  height = 1050 - margin.top - margin.bottom,\n  domain = d3.set(numericCols).values(),\n  colorScale = d3.scaleLinear() // our color scale fom red to white to blue\n    .domain([-1, 0, 1])\n    .range([\"#B22222\", \"#fff\", \"#000080\"]);\n\n// set-up x and y scale\nlet x = d3.scaleOrdinal()\n    .range([0, width])\n    .domain(domain),\n  y = d3.scaleOrdinal()\n    .range([0, height])\n    .domain(domain)\n\nlet svgElt = d3.select(\"#heavyUserPlot\")\n  .html(\"\") //clear the canvas\n  .append(\"svg\")\n  .attr(\"width\", width + margin.left + margin.right)\n  .attr(\"height\", height + margin.top + margin.bottom)\n\nlet corrMatGroup = svgElt.append(\"g\")\n  .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\");\n\nlet squareEdge = 15; //the length of an edge of a cell in the corr matrix\nlet corrMatrixEdge = squareEdge*(1+nb.shape(rankCorrMat)[0]); //the length of an edge of the whole corr matrix\n\nlet fontSize = 10.5;\n\ncorrMatGroup.selectAll(\"rect.correlation\")\n  .data(indices).enter()\n  .append(\"rect\").attr(\"class\", \"correlation\")\n  .attr(\"width\", squareEdge-1).attr(\"height\", squareEdge-1)\n  .attr(\"x\", ij => ij[1]*squareEdge - squareEdge/2)\n  .attr(\"y\", ij => ij[0]*squareEdge - squareEdge/2)\n  .style(\"fill\", ij => colorScale(rankCorrMat[ij[0]][ij[1]]))\n  .on(\"mouseover\", mouseoverHighlight)\n  .on(\"mouseout\", mouseoutUnhighlight)\n  .on(\"click\", ij => mousedownShowDetails(numericCols[ij[0]],numericCols[ij[1]]) )\n\ncorrMatGroup.append(\"g\").attr(\"class\", \"rowLabels\")\n    .selectAll(\"text\")\n    .data(numericCols).enter()\n    .append(\"text\")\n    .attr(\"x\", -squareEdge).attr(\"y\", (d,i) => i*squareEdge).attr(\"dy\", \".32em\")\n    .attr(\"text-anchor\", \"end\").attr(\"font-size\", fontSize)\n    .text(d => d);\n\ncorrMatGroup.append(\"g\").attr(\"class\", \"rowLabels\")\n    .attr(\"transform\", \"rotate(-90)\")\n    .selectAll(\"text\")\n    .data(numericCols).enter()\n    .append(\"text\")\n    .attr(\"x\", +squareEdge).attr(\"y\", (d,i) => i*squareEdge).attr(\"dy\", \".32em\")\n    .attr(\"font-size\", fontSize)\n    .text(d => d)\n\nlet corrDetailFontSize = 13\ncorrelationDetailText1 = corrMatGroup\n    .append(\"text\")\n    .attr(\"x\", -squareEdge/2).attr(\"y\", corrMatrixEdge+5)\n    .attr(\"font-size\", corrDetailFontSize)\ncorrelationDetailText2 = corrMatGroup\n    .append(\"text\")\n    .attr(\"x\", -squareEdge/2).attr(\"y\", corrMatrixEdge+10+corrDetailFontSize)\n    .attr(\"font-size\", corrDetailFontSize)\n\nfunction mouseoverHighlight(d,i){\n  // d is [i,j],\n  var [i,j] = [d[0],d[1]]\n  d3.select(this).attr(\"stroke\", \"red\").attr('stroke-width', '3px');\n  correlationDetailText1.text(`${numericCols[i]} vs ${numericCols[j]}`)\n  correlationDetailText2.text(`Rank Correlation: ${nb.prettyFormatNumber(rankCorrMat[i][j],4)}`)\n}\n\nfunction mouseoutUnhighlight(d,i){\n  // d is [i,j],\n  var [i,j] = [d[0],d[1]]\n  d3.select(this).attr(\"stroke\", \"none\");\n}\n\n\nfunction addCanvasPlotToSvg(svgElt,xPos,yPos,width,height,axisTextOffset){\n  let canvasGroup = svgElt\n    .append(\"g\").attr(\"transform\", `translate(${xPos},${yPos})`)\n  // add foreign object to svg-- https://gist.github.com/mbostock/1424037\n  let foreignObject = canvasGroup.append(\"foreignObject\")\n    .attr(\"width\", width).attr(\"height\", height);\n  // add embedded body to foreign object\n  let foBody = foreignObject.append(\"xhtml:body\")\n      .style(\"margin\", \"0px\").style(\"padding\", \"0px\")\n      .style(\"background-color\", \"none\")\n      .style(\"width\", width+\"px\").style(\"height\", height+\"px\")\n  // add embedded canvas to embedded body\n  let canvas = foBody.append(\"canvas\")\n      .attr(\"width\", width).attr(\"height\", height)\n  return {\n    canvas: canvas,\n    ctx: canvas.node().getContext(\"2d\"),\n    xAxisGroup : canvasGroup.append(\"g\")\n    \t.attr(\"transform\", \"translate(0,\" + (height + 5) + \")\"),\n\tyAxisGroup: canvasGroup.append(\"g\")\n    \t.attr(\"transform\", \"translate(-5,0)\"),\n    xText: canvasGroup.append(\"text\")             \n      .attr(\"transform\",`translate(${width/2},${height + axisTextOffset})`)\n      .style(\"text-anchor\", \"middle\"),\n\tyText: canvasGroup.append(\"text\")             \n      .attr(\"transform\",`translate(${-axisTextOffset},${height/2})rotate(-90)`)\n      .style(\"text-anchor\", \"middle\"),\n    title: canvasGroup.append(\"text\")             \n        .attr(\"transform\",`translate(${width/2},${-20})`)\n        .style(\"text-anchor\", \"middle\") \n  }\n}\n\nvar twoPi = Math.PI*2\nlet axisTextOffset = 45\n\nlet canvasDimRank = {width:250, height:250},\n    canvasPosRank = {x:500, y:margin.top+corrMatrixEdge+150}\nlet rankPlot = addCanvasPlotToSvg(svgElt, canvasPosRank.x, canvasPosRank.y,\n                     canvasDimRank.width, canvasDimRank.height, axisTextOffset)\n\nlet canvasPosRaw = {x:100, y:margin.top+corrMatrixEdge+150}\nlet rawPlot = addCanvasPlotToSvg(svgElt, canvasPosRaw.x, canvasPosRaw.y,\n                     canvasDimRank.width, canvasDimRank.height, axisTextOffset)\n\nlet detailPlotTitles = svgElt.append(\"g\")\n    .attr(\"transform\",\n          `translate(${(canvasPosRank.x+canvasPosRaw.x+canvasDimRank.width)/2},\n            ${margin.top+corrMatrixEdge+80})`)\n\nfunction mousedownShowDetails(xCol,yCol) {\n  detailPlotTitles.html(\"\")\n  detailPlotTitles.append(\"text\")\n  \t.style(\"text-anchor\", \"middle\")\n  \t.text(`${xCol} vs. ${yCol}`)\n  let thisRankCorr = nb.prettyFormatNumber(\n    rankCorrMat[numericCols.indexOf(xCol)][numericCols.indexOf(yCol)],4)\n  detailPlotTitles.append(\"text\")\n  \t.style(\"text-anchor\", \"middle\").attr(\"y\",20)\n  \t.text(`(rank correlation: ${thisRankCorr})`)\n  rankPlot.title.text(`Percentile vs. percentile`);\n  rankPlot.xText.text(`Percentile of ${xCol}`);\n  rankPlot.yText.text(`Percentile of ${yCol}`); \n  rawPlot.title.text(`raw values (central ${(1-centralProp)*100}%)`);\n  rawPlot.xText.text(`${xCol}`);\n  rawPlot.yText.text(`${yCol}`);\n  let [xMin,xMax] = d3.extent(rankColDf[xCol])\n  let [yMin,yMax] = d3.extent(rankColDf[yCol])\n  let xScaleRank = d3.scaleLinear()\n      .domain([0, 1]).range([0, canvasDimRank.width]); \n  let yScaleRank = d3.scaleLinear()\n      .domain([0, 1]).range([canvasDimRank.height, 0]);\n  rankPlot.xAxisGroup.call(d3.axisBottom(xScaleRank).ticks(4));\n  rankPlot.yAxisGroup.call(d3.axisLeft(yScaleRank).ticks(4));\n  \n  let xScaleRaw = d3.scaleLinear()\n    .domain(centralExtents[xCol])\n  \t.range([0, canvasDimRank.width]); \n  let yScaleRaw = d3.scaleLinear()\n    .domain(centralExtents[yCol])\n    .range([canvasDimRank.height, 0]);\n  rawPlot.xAxisGroup.call( d3.axisBottom(xScaleRaw).ticks(5,\"s\") );\n  rawPlot.yAxisGroup.call( d3.axisLeft(yScaleRaw).ticks(5,\"s\") );\n  // update canvas\n  // clear canvas\n  rankPlot.ctx.clearRect(0, 0, canvasDimRank.width, canvasDimRank.height);\n  rawPlot.ctx.clearRect(0, 0, canvasDimRank.width, canvasDimRank.height);\n // set opacity for data elements\n  rankPlot.ctx.globalAlpha = scatterAlpha;\n  rawPlot.ctx.globalAlpha = scatterAlpha;\n  // draw the data\n  rankRowDf.slice().forEach(function(d,i) {\n    if (d[xCol] && d[yCol]){\n      rankPlot.ctx.beginPath();\n      rankPlot.ctx.arc(xScaleRank(d[xCol]/xMax), yScaleRank(d[yCol]/yMax),\n                       scatterPointSize, 0, twoPi, true);\n      rankPlot.ctx.fillStyle = \"#000\";\n      rankPlot.ctx.closePath();\n      rankPlot.ctx.fill();\n      \n      rawPlot.ctx.beginPath();\n      rawPlot.ctx.arc(xScaleRaw(df[i][xCol]), yScaleRaw(df[i][yCol]),\n                       scatterPointSize, 0, twoPi, true);\n      rawPlot.ctx.fillStyle = \"#000\";\n      rawPlot.ctx.closePath();\n      rawPlot.ctx.fill();\n    }\n  })\n}\nmousedownShowDetails(xColInit,yColInit);","id":13,"cellType":"javascript","rendered":true,"selected":false,"executionStatus":"18","evaluationOld":true,"collapseEditViewInput":"SCROLLABLE","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"COLLAPSED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"<div id=\"heavyUserPlot\"></div>","id":29,"cellType":"markdown","value":"<div id=\"heavyUserPlot\"></div>","rendered":true,"selected":false,"executionStatus":" ","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"EXPANDED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"Key questions:\n\nMost measures of usage show a high degree of correlation, as expected. For example:\n- <a onclick=\"mousedownShowDetails('uri_count_total','active_ticks_total')\"> Page loads vs active time</a>\n- <a onclick=\"mousedownShowDetails('uri_count_total','tab_open_event_total')\"> Page loads vs tab open events</a>\n\nThis should give us confidence in making the generalization that for many practical purposes, there is essentially one underlying dimension of \"activity\" -- that is, we don't have to worry too much about the existence of large groups of users who e.g. view a lot of pages but don't open many tabs.\n\nHowever, we see very little correlation between activity and hardware spec:\n- <a onclick=\"mousedownShowDetails('uri_count_total','cores')\"> Page loads vs Number of cores</a>\n- <a onclick=\"mousedownShowDetails('uri_count_total','speed_mhz')\"> Page loads vs cpu speed</a>\n- <a onclick=\"mousedownShowDetails('uri_count_total','memory_mb')\"> Page loads vs RAM</a>\n\nWhile there is a very weak relationship here, the evidence undermines the idea that \"heavy users\" are also \"power users\" or \"tech enthusiasts\" with high-spec machines, or that people whith high-spec machines always do a lot more browsing. \n","id":46,"cellType":"markdown","value":"<p>Key questions:</p>\n<p>Most measures of usage show a high degree of correlation, as expected. For example:</p>\n<ul>\n<li><a onclick=\"mousedownShowDetails('uri_count_total','active_ticks_total')\"> Page loads vs active time</a></li>\n<li><a onclick=\"mousedownShowDetails('uri_count_total','tab_open_event_total')\"> Page loads vs tab open events</a></li>\n</ul>\n<p>This should give us confidence in making the generalization that for many practical purposes, there is essentially one underlying dimension of &quot;activity&quot; -- that is, we don't have to worry too much about the existence of large groups of users who e.g. view a lot of pages but don't open many tabs.</p>\n<p>However, we see very little correlation between activity and hardware spec:</p>\n<ul>\n<li><a onclick=\"mousedownShowDetails('uri_count_total','cores')\"> Page loads vs Number of cores</a></li>\n<li><a onclick=\"mousedownShowDetails('uri_count_total','speed_mhz')\"> Page loads vs cpu speed</a></li>\n<li><a onclick=\"mousedownShowDetails('uri_count_total','memory_mb')\"> Page loads vs RAM</a></li>\n</ul>\n<p>While there is a very weak relationship here, the evidence undermines the idea that &quot;heavy users&quot; are also &quot;power users&quot; or &quot;tech enthusiasts&quot; with high-spec machines, or that people whith high-spec machines always do a lot more browsing.</p>\n","rendered":true,"selected":false,"executionStatus":" ","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"EXPANDED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}},{"content":"_Note: This notebook is based on data from early 2017_","id":47,"cellType":"markdown","value":"<p><em>Note: This notebook is based on data from early 2017</em></p>\n","rendered":true,"selected":false,"executionStatus":" ","evaluationOld":true,"collapseEditViewInput":"EXPANDED","collapseEditViewOutput":"EXPANDED","collapsePresentationViewInput":"COLLAPSED","collapsePresentationViewOutput":"EXPANDED","collapsed":{"input":{"editor":"EXPANDED","presentation":"COLLAPSED"},"output":{"editor":"EXPANDED","presentation":"EXPANDED"}}}],"declaredProperties":{},"lastSaved":"2017-11-07T19:57:39.265Z","mode":"edit","viewMode":"editor","history":[],"externalScripts":[],"executionNumber":0}